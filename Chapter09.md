───────────────────────────────────────────
약삭빠른 코드 대신 명료하고 이해하기 쉬운 프로그램을 작성하라.


while(‘\n’ != (x++ = y++){
   ...내용...
}
while(1){
   x=y;
   if(x=’\n’){
      break;
   }
   x++;
   y++;
}
×
○

⦁문제점
 복잡한 코드를 한 줄에 표현하였지만, 한 번에 이해하기 어려울 뿐만 아니라, 수정하기에도 큰 어려움이 있다.

⦁결론
 코드의 길이가 짧다고 성능이 크게 차이가 나는 것도 아니기 때문에 명료하게 작성하는 것이 유지보수하기에 더 수월하다.(주석까지 추가해주면 더욱 좋다.)

───────────────────────────────────────────
 while 문에서 관계/대입 연산자의 우선순위를 혼동하지 마라


while(c = getchar()!=EOF){
   putchar(c);
}
c = getchar();
while(c!=EOF){
   putchar(c);
   c=getchar();
}
×
○

⦁문제점
 코드 작성자의 의도와는 다르게 연산순서가 달라질 수 있다.

⦁우선순위
C언어에서 우선순위 관계연산자 > 대입연산자
JAVA에서 우선순위 대입연산자 > 관계연산자

⦁결론
 프로그래머가 늘 우선순위를 기억하고 고려할 수는 없기 때문에 while, for, if문과 같은 조건식 안에서 조건 연산 외에 다른 연산을 하지 않으면 좋다.

───────────────────────────────────────────
───────────────────────────────────────────
 암시적인 ‘non zero test’를 하지 마라


while(function()){
   ...내용...
}
while( function() != 0 ){
   ...내용...
}
while(function() != false){
   ...내용...
}
×
○
○

⦁문제점
 0이외에 모든 값을 참으로 보는 컴파일러(C컴파일러)가 있는 반면 –1도 거짓으로 보는 컴파일러도 있다. 컴파일러로 변경되는 경우 프로그램을 수정하는 노력을 기울여야한다.

⦁예방 방법
1. 0을 명시적으로 표현하는 것
2. 0 대신에 FALSE라는 기호 상수로 표현하는 것

⦁결론
 컴파일러에 따라 기준이 다르기 때문에 명시적인 조건을 걸어주는 것이 좋다.

───────────────────────────────────────────
조건식에 대입문을 사용하지 마라


if( (value=a++/20)<10 ){
   System.out.println(value+“입니다”);
}
if(1){
   value=a/20;
   a++;
   if(value>=0){
       break;
   }
   System.out.println(value+“입니다”);
}
×
○

⦁문제점
 조건문 안에 대입문을 쓰는 경우 이해하기 어려울 뿐만 아니라, 조건문 안에 대입문만 사용하여 0이 되었을 때 조건문이 아예 실행이 안 될 수도 있다.(예: if(value=0) )


⦁결론
while, if, for, do, switch 등의 조건문에서 가능한 한 대입문을 사용하지 않는 게 좋다.


───────────────────────────────────────────

───────────────────────────────────────────
 부작용이 나타나지 않도록 주의하라

int num=1;
result=(++num*5)+(++num*10);
int num=1;
num++;
result=number*5;
num++;
result=result+(num*10);
×
○

⦁문제점
 동일한 우선순위인 경우 컴파일러의 처리방식에 따라서 앞쪽의 연산을 먼저 계산할 수도 있고 그 반대일 수도 있다. 따라서 이렇게 부작용을 가져올 수 있는 코드는 지양하는 것이 좋다.

⦁예방 방법
 문장을 나누어서 코드를 작성한다. 이는 부작용에 대한 가능성을 배제함과 동시에 보기에 이해하기도 쉬운 코드가 될 수 있다.

⦁결론
 기존의 컴파일 오류와 논리적인 오류들 외에도 또 다른 제3의 오류가 존재한다. 이는 명확하게 찾아내기 힘들기 때문에 KISS원칙에 따라서 프로그램을 작성하는 것이 좋다.

※ KISS는 “Keep it small and simple.”, “Keep it short and simple.”, 또는 “Keep it simple, stupid.”의 첫 글자만 따서 만든 약어로, KISS 원칙이란 디자인에서 간단하고 알기 쉽게 만드는 편이 좋다는 원리를 말한다.

───────────────────────────────────────────
가인수에도 이름을 기입하라


int Sum(int a, int b){
   ...내용...
}
int Sum(int englishTotal, int mathTotal){
   ...내용...
}
×
○

⦁문제점 
 복잡한 함수의 경우 인수(Parameter)의 이름을 임의로 지정하게 되면 함수의 인수가 어떤 역할을 하는지 확인하기 어려울 수 있다.

⦁결론
 가인수의 자료형 옆에 가인수에 전달되는 자료의 성경을 나타내는 이름을 달아두면 프로그램을 이해하는데 더 큰 도움이 된다.

───────────────────────────────────────────
───────────────────────────────────────────반환 자료형을 반드시 표기하라(C언어)


main(){
   ...내용..
}
int main(){
   ...내용..
}
×
○


⦁문제점 
 C언어의 경우 위처럼 암시적인 함수정의 방식에서 int형으로 반환하지만 컴파일러에 따라서 다른 방식으로 처리될 수 있으며, 이는 문제를 일으킬 수 있다.

⦁결론
 함수를 정의할 때 자료형을 명확히 정의해두는 것이 잠재적인 오류를 제거하기에 좋다. 반환자료형이 없다면 void로 표기하는 것이 좋다.

───────────────────────────────────────────
결과 값에 주의하라(C언어)


if(strcmp(string1,string2)){
   printf(“두 문자열이 동일합니다.”);
}
else{
   printf(“두 문자열이 다릅니다.”);
}



⦁문제점 
 strcmp의 경우 두 값이 같을 때 0을 반환하기 때문에 위의 경우 두 문자열 같음에도 불구하고 다르다는 문구를 출력하게 된다.

⦁결론
 자바에서든지, C언어에서든지 반환 값에 대해서 관행적으로 접근하는 것 보다는 매뉴얼이라든지 함수 사양서를 확인하고 프로그래밍을 하는 것이 좋다. 또한 이를 주석의 형태로 기술하면 더더욱 좋을 것이다.


───────────────────────────────────────────


───────────────────────────────────────────
 for문 등의 조건에서 연산하는 일을 지양하자

for(j=x ; j<=x*10 ; j+=x/2){
   ...내용...
}
y=x*10; //10은 연 단위
z=x/2;  //연을 분기로 나눔
for(j=x ; j<=y ; j+=z){
   ...내용...
}
×
○


⦁문제점 
 “ 조건식에 대입문을 사용하지 마라. ”　에서 말했던 것처럼 조건 식 안에서 많은 연산을 하고 있다. 이는 명료하지 못하기 때문에 이해의 어려움, 부작용 등의 문제를 만들 수 있다.

⦁결론
 우측에서처럼 계산하는 연산부분을 분리함으로써 잠재적인 오류를 줄일 수 있고, 주석으로 설명하기도 쉽다.

───────────────────────────────────────────




## [미진행] 
2016 July 26 
───────────────────────────────────────────
약삭빠른 코드 대신 명료하고 이해하기 쉬운 프로그램을 작성하라.


while(‘\n’ != (x++ = y++){
   ...내용...
}
while(1){
   x=y;
   if(x=’\n’){
      break;
   }
   x++;
   y++;
}
×
○

⦁문제점
 복잡한 코드를 한 줄에 표현하였지만, 한 번에 이해하기 어려울 뿐만 아니라, 수정하기에도 큰 어려움이 있다.

⦁결론
 코드의 길이가 짧다고 성능이 크게 차이가 나는 것도 아니기 때문에 명료하게 작성하는 것이 유지보수하기에 더 수월하다.(주석까지 추가해주면 더욱 좋다.)

───────────────────────────────────────────
 while 문에서 관계/대입 연산자의 우선순위를 혼동하지 마라


while(c = getchar()!=EOF){
   putchar(c);
}
c = getchar();
while(c!=EOF){
   putchar(c);
   c=getchar();
}
×
○

⦁문제점
 코드 작성자의 의도와는 다르게 연산순서가 달라질 수 있다.

⦁우선순위
C언어에서 우선순위 관계연산자 > 대입연산자
JAVA에서 우선순위 대입연산자 > 관계연산자

⦁결론
 프로그래머가 늘 우선순위를 기억하고 고려할 수는 없기 때문에 while, for, if문과 같은 조건식 안에서 조건 연산 외에 다른 연산을 하지 않으면 좋다.

───────────────────────────────────────────
───────────────────────────────────────────
 암시적인 ‘non zero test’를 하지 마라


while(function()){
   ...내용...
}
while( function() != 0 ){
   ...내용...
}
while(function() != false){
   ...내용...
}
×
○
○

⦁문제점
 0이외에 모든 값을 참으로 보는 컴파일러(C컴파일러)가 있는 반면 –1도 거짓으로 보는 컴파일러도 있다. 컴파일러로 변경되는 경우 프로그램을 수정하는 노력을 기울여야한다.

⦁예방 방법
1. 0을 명시적으로 표현하는 것
2. 0 대신에 FALSE라는 기호 상수로 표현하는 것

⦁결론
 컴파일러에 따라 기준이 다르기 때문에 명시적인 조건을 걸어주는 것이 좋다.

───────────────────────────────────────────
조건식에 대입문을 사용하지 마라


if( (value=a++/20)<10 ){
   System.out.println(value+“입니다”);
}
if(1){
   value=a/20;
   a++;
   if(value>=0){
       break;
   }
   System.out.println(value+“입니다”);
}
×
○

⦁문제점
 조건문 안에 대입문을 쓰는 경우 이해하기 어려울 뿐만 아니라, 조건문 안에 대입문만 사용하여 0이 되었을 때 조건문이 아예 실행이 안 될 수도 있다.(예: if(value=0) )


⦁결론
while, if, for, do, switch 등의 조건문에서 가능한 한 대입문을 사용하지 않는 게 좋다.


───────────────────────────────────────────

───────────────────────────────────────────
 부작용이 나타나지 않도록 주의하라

int num=1;
result=(++num*5)+(++num*10);
int num=1;
num++;
result=number*5;
num++;
result=result+(num*10);
×
○

⦁문제점
 동일한 우선순위인 경우 컴파일러의 처리방식에 따라서 앞쪽의 연산을 먼저 계산할 수도 있고 그 반대일 수도 있다. 따라서 이렇게 부작용을 가져올 수 있는 코드는 지양하는 것이 좋다.

⦁예방 방법
 문장을 나누어서 코드를 작성한다. 이는 부작용에 대한 가능성을 배제함과 동시에 보기에 이해하기도 쉬운 코드가 될 수 있다.

⦁결론
 기존의 컴파일 오류와 논리적인 오류들 외에도 또 다른 제3의 오류가 존재한다. 이는 명확하게 찾아내기 힘들기 때문에 KISS원칙에 따라서 프로그램을 작성하는 것이 좋다.

※ KISS는 “Keep it small and simple.”, “Keep it short and simple.”, 또는 “Keep it simple, stupid.”의 첫 글자만 따서 만든 약어로, KISS 원칙이란 디자인에서 간단하고 알기 쉽게 만드는 편이 좋다는 원리를 말한다.

───────────────────────────────────────────
가인수에도 이름을 기입하라


int Sum(int a, int b){
   ...내용...
}
int Sum(int englishTotal, int mathTotal){
   ...내용...
}
×
○

⦁문제점 
 복잡한 함수의 경우 인수(Parameter)의 이름을 임의로 지정하게 되면 함수의 인수가 어떤 역할을 하는지 확인하기 어려울 수 있다.

⦁결론
 가인수의 자료형 옆에 가인수에 전달되는 자료의 성경을 나타내는 이름을 달아두면 프로그램을 이해하는데 더 큰 도움이 된다.

───────────────────────────────────────────
───────────────────────────────────────────반환 자료형을 반드시 표기하라(C언어)


main(){
   ...내용..
}
int main(){
   ...내용..
}
×
○


⦁문제점 
 C언어의 경우 위처럼 암시적인 함수정의 방식에서 int형으로 반환하지만 컴파일러에 따라서 다른 방식으로 처리될 수 있으며, 이는 문제를 일으킬 수 있다.

⦁결론
 함수를 정의할 때 자료형을 명확히 정의해두는 것이 잠재적인 오류를 제거하기에 좋다. 반환자료형이 없다면 void로 표기하는 것이 좋다.

───────────────────────────────────────────
결과 값에 주의하라(C언어)


if(strcmp(string1,string2)){
   printf(“두 문자열이 동일합니다.”);
}
else{
   printf(“두 문자열이 다릅니다.”);
}



⦁문제점 
 strcmp의 경우 두 값이 같을 때 0을 반환하기 때문에 위의 경우 두 문자열 같음에도 불구하고 다르다는 문구를 출력하게 된다.

⦁결론
 자바에서든지, C언어에서든지 반환 값에 대해서 관행적으로 접근하는 것 보다는 매뉴얼이라든지 함수 사양서를 확인하고 프로그래밍을 하는 것이 좋다. 또한 이를 주석의 형태로 기술하면 더더욱 좋을 것이다.


───────────────────────────────────────────


───────────────────────────────────────────
 for문 등의 조건에서 연산하는 일을 지양하자

for(j=x ; j<=x*10 ; j+=x/2){
   ...내용...
}
y=x*10; //10은 연 단위
z=x/2;  //연을 분기로 나눔
for(j=x ; j<=y ; j+=z){
   ...내용...
}
×
○


⦁문제점 
 “ 조건식에 대입문을 사용하지 마라. ”　에서 말했던 것처럼 조건 식 안에서 많은 연산을 하고 있다. 이는 명료하지 못하기 때문에 이해의 어려움, 부작용 등의 문제를 만들 수 있다.

⦁결론
 우측에서처럼 계산하는 연산부분을 분리함으로써 잠재적인 오류를 줄일 수 있고, 주석으로 설명하기도 쉽다.

───────────────────────────────────────────




